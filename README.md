下载本代码前请注意配置redis，nginx,mq和zookeeper
数据库脚本在src/main/resource/sql下，启动前请自行导入
## 业务难点：瞬间高并发
规模：几百几千不成问题，如果是百万级，千万级，建议使用分布式集群
## 实现原理：
- 1.用户访问会首先经过一个高防ip，来防止ddos攻击
- 2.经过slb对多台云服务器进行流量分发，通过流量分发扩展应用系统对外的服务能力，通过消除单点故障提升应用系统的可用性。
- 3.针对slb价格和灵活性考虑，接入nginx做限流分发，保证后端服务的正常运行
- 4.后台秒杀给予redis或者Zookeeper分布式锁，Kifka或者Redis做消息队列，drds数据库中间件实现数据的读写分离
## 秒杀架构
![架构图](https://gitee.com/uploads/images/2018/0515/184617_c7e13059_87650.png "秒杀架构.png")

## 优化思路：
- 分流
- 限流
- 缓存
- 异步
- 主备容灾方案
- 对服务器部署模型进行优化，部分请求直接返回秒杀失败
## 前端优化：
活动开始前生成静态商品页面推送缓存和cdn,静态文件（js/css）请求推送至文件服务器和cdn
## 应用服务优化：
nginx最佳配置，tomcat连接池优化，数据库配置优化和数据库连接池优化

## 多线程使用
先创建私有化的静态线程池,然后在控制层方法中创建Runable对象,在接口
方法的实现内书写程序的逻辑代码

## 程序锁使用
相对于Synchronize，Lock在获取锁的操作上提供了阻塞、非阻塞可中断、超时设置等机制
service在程序中是默认单例的,并发下lock只有一个实例
这里使用lock来实现程序锁,预先在程序中创建一个lock对象,使用时调用lock()加锁
,最后调用unlock（）释放锁，因为这一过程可能发生错误，所以使用try是必要的
在test目录下做了两者性能的测试，可以做大致的性能参考


下面记录我做本系统以来遇到的问题，在这里提一下防止有后人再犯百度解决耗时费力
- 1 找不到dao层接口内的方法：.properties或者yml文件mybatis文件路径前面必须有/
- 2.空指针,就是没有参数,首先看url是否缺少参数
- 3.405：请求方式有误.浏览器输入必须是get方式,post只能由系统内部调用,并非错误

    